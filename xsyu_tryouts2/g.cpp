/*************************************************************************
	> File Name: g.cpp
	> Author: Sakurarry
	> Mail: solzeair@gmail.com
	> Created Time: Thu 24 Apr 2025 06:27:18 PM CST
 ************************************************************************/

/*
 * CF1876B Effects of Anti Pimples
 *
 * 题目描述：
 * 给定长度为 n 的数组 a[1..n]，初始所有元素均为白色（未选中）。
 * 选手可以选择一个或多个不同的下标，将这些下标对应的元素染为黑色。
 * 随后，对所有白色元素，如果其下标是任意一个黑色元素下标的倍数，则将该白色元素染为绿色。
 * 最终得分定义为所有黑色和绿色元素中 a_i 的最大值。
 * 要求计算所有非空黑色集合（共有 2^n-1 种选择）对应得分的总和，结果对 998244353 取模输出。
 *
 * 解题思路：
 * 1. 关键在于：对于每次选择的黑色下标集合 B，其影响到的黑/绿元素集合恰好是所有下标 i
 *    使得 i 能被 B 中至少一个元素整除的下标集合。该集合中的最大值即为这些下标对应 a[i] 的最大值。
 * 2. 注意到，无论如何选择黑色集合 B，其最终得分都等于所选黑色最大下标及其所有倍数位置的 a 值的最大值。
 *    换句话说，如果令 f(i) 表示以 i 作为最小黑色下标时能够覆盖的所有位置的最大 a 值。
 *    那么，对于排序后的 f(1),f(2),...,f(n)，任取 k 个黑色下标，其中这 k 个下标中最小的为 i，则得分为 f(i)。
 * 3. 对于固定 i，选择的黑色下标的最小值是 i 的方案数为：在 i 之后的所有位置中任选（可选可不选）
 *    且至少要保证不选比 i 更小的黑色下标，因此数量为 2^{n-i}。
 *    但我们枚举时先对 f 数组排序升序，则更简单地：令 b 数组为 f 排序后结果，
 *    b[1] <= b[2] <= ... <= b[n]。第 i 小的值 b[i] 会恰好被作为当前的 "最小黑色覆盖" 的值
 *    出现 C(n, i) 次，但组合计数可累乘幂。
 * 4. 易得答案 = sum_{i=1..n} b[i] * 2^{i-1}，再对 mod 998244353 取模。
 *
 * 算法实现：
 * - 先预处理：对于每个 i 从大到小遍历其所有倍数 j，更新 a[i] = max(a[i], a[j])，计算 f(i)。
 * - 对 f 数组排序。
 * - 预计算 2^k 模 mod（k = 0..n）。
 * - 按排序后顺序累加 ans += f_sorted[i] * 2^{i-1} % mod。
 * - 输出 ans。
 *
 * 时间复杂度：O(n log n + n/1 + n/2 + ... + n/n) ≈ O(n log n)
 * 空间复杂度：O(n)
 */

#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;

#define MAX_N 100000
const long long mod = 998244353;

int n, a[MAX_N + 5];      // 存储输入数组及 f(i) 值
ll p[MAX_N + 5] = {1};     // p[i] = 2^i mod mod

int main() {
    cin >> n;              // 读入数组长度 n
    for (int i = 1; i <= n; i++) cin >> a[i];  // 读入数组元素 a[1..n]

    // 计算 f(i)：对于每个 i，将其所有倍数位置的值纳入考虑，取最大值
    for (int i = 1; i <= n; i++) {
        for (int j = 2 * i; j <= n; j += i) {
            a[i] = max(a[i], a[j]);  // 更新 a[i] 为自身及所有倍数位置的最大值
        }
    }

    // 对 f(i) 值进行排序，方便累加组合权重
    sort(a + 1, a + n + 1);

    // 预计算 p[i] = 2^i mod mod
    for (int i = 1; i <= n; i++) p[i] = p[i - 1] * 2 % mod;

    ll ans = 0;
    // 计算最终答案：sum_{i=1..n} a[i] * 2^{i-1} mod
    for (int i = 1; i <= n; i++) {
        ans += a[i] * p[i - 1] % mod;
        ans %= mod;
    }

    cout << ans;          // 输出结果
    return 0;
}

