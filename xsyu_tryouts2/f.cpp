/*************************************************************************
	> File Name: e.cpp
	> Author: Sakurarry
	> Mail: solzeair@gmail.com
	> Created Time: Sat 26 Apr 2025 12:44:36 PM CST
 ************************************************************************/

/*
题意：
给定一个由 '1'、'2'、'/' 组成的字符串 S，长度为 N，S 中至少包含一个 '/'。
我们定义一种“11/22 字符串”：
- 长度为奇数；
- 前 (len-1)/2 个字符为 '1'；
- 中间一个字符为 '/'；
- 后 (len-1)/2 个字符为 '2'。
例如："11/22", "111/222", "/" 都是合法的。

目标：
求 S 的所有子串中，最长的“11/22 字符串”的长度。

思路：
- 我们从左到右扫描字符串，维护一个当前合法子串的信息：
  - one：当前阶段连续的 '1' 数量（在 '/' 之前）；
  - flag：是否遇到过 '/'（1 表示遇到过）；
  - two：当前阶段连续的 '2' 数量（在 '/' 之后）；
- 每当遇到一个 '/'：
  - 如果前面已经有 '/' 或者已经进入 '2' 阶段，说明不合法，重新开始统计；
  - 否则将 flag 置为 1，并尝试更新最大长度（最小为 1，单独一个 '/' 也是合法的）；
- 每当遇到一个 '2'：
  - 如果没遇到 '/'，跳过；
  - 否则 two++，并更新最长长度为 min(one, two) * 2 + 1；
- 每当遇到一个 '1'：
  - 如果在 '/' 后还没开始读 '2'，说明要重新开始一个新的合法串，将 one 置为 1；
  - 否则 one++。

*/


#include <iostream>
#include <string>
using namespace std;

int main() {
    int n;
    cin >> n;               // 读入字符串长度（其实我们并不特别用 n，只读 S.size() 也行）
    string str;
    cin >> str;             // 读入原始字符串 S

    int one = 0;            // 当前子串中，斜杠前连续 '1' 的个数
    int two = 0;            // 当前子串中，斜杠后连续 '2' 的个数
    int flag = 0;           // 是否已经遇到斜杠 '/'（0: 否，1: 是）
    int ans = 0;            // 全局最大合法子串长度

    // 从左到右逐字符扫描
    for (int i = 0; str[i]; i++) {
        switch (str[i]) {
            case '1': {
                // 读到 '1'
                if (flag) {
                    // 情况：刚读到一个 '/'，还没读到任何 '2'
                    // 此时如果接着读 '1'，就说明要丢弃之前的 "/"，重新开始
                    flag = 0;    // 斜杠失效
                    two  = 0;    // 斜杠后阶段重置
                    one  = 1;    // 从这一颗 '1' 重新开始计数
                } else {
                    // 还在斜杠前读 '1' 的阶段，或刚好还没遇到 '/'，累加
                    one += 1;
                }
            } break;
            case '/': {
                // 读到 '/'
                if (two || flag) {
                    // 如果之前已经开始了一个合法段（读到过 '/' 后又读到 '2'）
                    // 或者连续读到多个 '/'，都要重开
                    one = 0;
                    two = 0;
                }
                flag = 1;          // 标记：已经遇到中间的 '/'
                ans = max(ans, flag); // 单独一个 '/' 长度就是 1，更新答案
            } break;
            case '2': {
                // 读到 '2'
                if (flag == 0) {
                    // 斜杠还没出现，'2' 无法成为合法子串一部分
                    one = 0;
                    two = 0;
                    flag = 0;
                    continue;      // 跳到下一个字符
                }
                // 处在斜杠后阶段，累加 '2'
                two += 1;
                // 此时能取两侧 min(one,two) 对 '1'/'2'，加上中间一个 '/'
                int cur = min(one, two) * 2 + flag;
                ans = max(ans, cur);
            } break;
        }
    }

    cout << ans << endl;  // 输出结果
    return 0;
}

